import dotenv from 'dotenv';
dotenv.config();

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { v0 } from 'v0-sdk';
import fs from 'fs/promises';
import path from 'path';

export function registerV0Tools(server: McpServer) {
  // Tool: Generate component using v0.dev API
  server.registerTool(
    "generate-component",
    {
      title: "Generate Component",
      description: "Generate a React/Next.js component using v0.dev API",
      inputSchema: {
        prompt: z.string().describe("Description of the component to generate"),
        model: z.string().optional().describe("Model to use (defaults to environment variable V0_MODEL)")
      }
    },
    async ({ prompt, model }) => {
      try {
        const chat = await v0.chats.create({
          message: prompt
        });

        if (chat.files && chat.files.length > 0) {
          return {
            content: [
              {
                type: "text",
                text: `Successfully generated ${chat.files.length} file(s):`
              },
              ...chat.files.map((file, index) => ({
                type: "text" as const,
                text: `\n--- File ${index + 1} ---\n${file.source}`
              }))
            ]
          };
        } else {
          return {
            content: [{
              type: "text",
              text: "No files were generated by v0.dev API"
            }]
          };
        }
      } catch (error: any) {
        return {
          content: [{
            type: "text",
            text: `Error generating component: ${error.message}`
          }]
        };
      }
    }
  );

  // Tool: Apply component with merge strategy
  server.registerTool(
    "apply-component",
    {
      title: "Apply Component",
      description: "Apply generated component files to a project with configurable merge strategy",
      inputSchema: {
        files: z.array(z.object({
          name: z.string(),
          content: z.string()
        })).describe("Array of files to apply"),
        targetPath: z.string().describe("Target directory path"),
        mergeStrategy: z.enum(["overwrite", "backup", "merge", "skip-existing", "preview"]).describe("How to handle existing files. options: overwrite, backup, merge, skip-existing, preview."),
        backupSuffix: z.string().optional().describe("Suffix for backup files (default: .backup)")
      }
    },
    async ({ files, targetPath, mergeStrategy, backupSuffix = ".backup" }) => {
      try {
        const results: string[] = [];
        
        // Ensure target directory exists
        await fs.mkdir(targetPath, { recursive: true });
        
        for (const file of files) {
          const filePath = path.join(targetPath, file.name);
          const fileExists = await fs.access(filePath).then(() => true).catch(() => false);
          
          switch (mergeStrategy) {
            case "overwrite":
              await fs.writeFile(filePath, file.content);
              results.push(`âœ“ Overwrote ${file.name}`);
              break;
              
            case "backup":
              if (fileExists) {
                const backupPath = filePath + backupSuffix;
                await fs.copyFile(filePath, backupPath);
                results.push(`ðŸ“‹ Backed up ${file.name} to ${path.basename(backupPath)}`);
              }
              await fs.writeFile(filePath, file.content);
              results.push(`âœ“ Applied ${file.name}`);
              break;
              
            case "skip-existing":
              if (fileExists) {
                results.push(`â­ï¸ Skipped existing ${file.name}`);
              } else {
                await fs.writeFile(filePath, file.content);
                results.push(`âœ“ Created ${file.name}`);
              }
              break;
              
            case "preview":
              results.push(`ðŸ‘ï¸ Preview ${file.name}:`);
              results.push(`   Path: ${filePath}`);
              results.push(`   Exists: ${fileExists ? "Yes" : "No"}`);
              results.push(`   Size: ${file.content.length} characters`);
              break;
              
            case "merge":
              if (fileExists) {
                const existingContent = await fs.readFile(filePath, 'utf-8');
                // Simple merge strategy: append new content with separator
                const mergedContent = existingContent + '\n\n// --- Generated by v0.dev ---\n' + file.content;
                await fs.writeFile(filePath, mergedContent);
                results.push(`ðŸ”€ Merged content into ${file.name}`);
              } else {
                await fs.writeFile(filePath, file.content);
                results.push(`âœ“ Created ${file.name}`);
              }
              break;
          }
        }
        
        return {
          content: [{
            type: "text",
            text: `Applied ${files.length} file(s) with strategy "${mergeStrategy}":\n${results.join('\n')}`
          }]
        };
      } catch (error: any) {
        return {
          content: [{
            type: "text",
            text: `Error applying component: ${error.message}`
          }]
        };
      }
    }
  );

  // Tool: List project files
  server.registerTool(
    "list-project-files",
    {
      title: "List Project Files",
      description: "List files in a project directory with optional filtering",
      inputSchema: {
        projectPath: z.string().describe("Path to the project directory"),
        pattern: z.string().optional().describe("File pattern to match (e.g., '*.tsx', '*.js')"),
        maxDepth: z.number().optional().describe("Maximum directory depth to traverse (default: 3)")
      }
    },
    async ({ projectPath, pattern, maxDepth = 3 }) => {
      try {
        const files: string[] = [];
        
        async function walkDir(dir: string, depth: number = 0) {
          if (depth > maxDepth) return;
          
          const entries = await fs.readdir(dir, { withFileTypes: true });
          
          for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            const relativePath = path.relative(projectPath, fullPath);
            
            if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
              await walkDir(fullPath, depth + 1);
            } else if (entry.isFile()) {
              if (!pattern || entry.name.match(new RegExp(pattern.replace('*', '.*')))) {
                files.push(relativePath);
              }
            }
          }
        }
        
        await walkDir(projectPath);
        
        return {
          content: [{
            type: "text",
            text: `Found ${files.length} files in ${projectPath}:\n${files.map(f => `  ${f}`).join('\n')}`
          }]
        };
      } catch (error: any) {
        return {
          content: [{
            type: "text",
            text: `Error listing files: ${error.message}`
          }]
        };
      }
    }
  );

  // Tool: Read file content
  server.registerTool(
    "read-file",
    {
      title: "Read File",
      description: "Read the content of a specific file",
      inputSchema: {
        filePath: z.string().describe("Path to the file to read")
      }
    },
    async ({ filePath }) => {
      try {
        const content = await fs.readFile(filePath, 'utf-8');
        return {
          content: [{
            type: "text",
            text: `Content of ${filePath}:\n\n${content}`
          }]
        };
      } catch (error: any) {
        return {
          content: [{
            type: "text",
            text: `Error reading file: ${error.message}`
          }]
        };
      }
    }
  );
}


